"use strict";(self.webpackChunkdev_book=self.webpackChunkdev_book||[]).push([[7081],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return k}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=s(n),k=i,c=u["".concat(p,".").concat(k)]||u[k]||m[k]||r;return n?a.createElement(c,l(l({ref:t},d),{},{components:n})):a.createElement(c,l({ref:t},d))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},964:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return p},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return m},default:function(){return k}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=n(1734),o=["components"],p={title:"User Guide"},s="User Guide",d={type:"mdx",permalink:"/dev-book/user-guide",source:"@site/src/pages/user-guide.mdx"},m=[{value:"What is <em>Jacy</em>?",id:"what-is-jacy",children:[],level:2},{value:"Lexical structure",id:"lexical-structure",children:[{value:"Comments",id:"comments",children:[],level:3},{value:"Identifiers",id:"identifiers",children:[],level:3},{value:"Keywords",id:"keywords",children:[],level:3},{value:"Operators",id:"operators",children:[{value:"Operator precedence table",id:"operator-precedence-table",children:[],level:4},{value:"<code>not</code> prefix",id:"not-prefix",children:[],level:4}],level:3},{value:"Punctuation",id:"punctuation",children:[],level:3}],level:2},{value:"Intro",id:"intro",children:[{value:"Primitive types &amp; Literals",id:"primitive-types--literals",children:[{value:"Boolean",id:"boolean",children:[],level:4},{value:"Character",id:"character",children:[],level:4},{value:"Integer types",id:"integer-types",children:[],level:4},{value:"Floating point types",id:"floating-point-types",children:[],level:4},{value:"Slice type",id:"slice-type",children:[],level:4},{value:"<code>str</code> / String Slice type",id:"str--string-slice-type",children:[],level:4},{value:"Tuple type",id:"tuple-type",children:[{value:"Unit type",id:"unit-type",children:[],level:5}],level:4},{value:"Array type",id:"array-type",children:[],level:4}],level:3},{value:"Functions",id:"functions",children:[{value:"Invocations with labels",id:"invocations-with-labels",children:[],level:4},{value:"Function overloading",id:"function-overloading",children:[],level:4}],level:3},{value:"Structures",id:"structures",children:[],level:3},{value:"Traits",id:"traits",children:[],level:3}],level:2}],u={toc:m};function k(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"user-guide"},"User Guide"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This is a WIP quick overview of ",(0,r.kt)("em",{parentName:"strong"},"Jacy")),"\n",(0,r.kt)("strong",{parentName:"p"},"You're unable to run any code present here. Please, think of this as an image from my mind \ud83e\udd7a")),(0,r.kt)("h2",{id:"what-is-jacy"},"What is ",(0,r.kt)("em",{parentName:"h2"},"Jacy"),"?"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Jacy")," is a small project, the reason I'm creating it is to learn compiler development and perhaps create an alternative to C++."),(0,r.kt)("h2",{id:"lexical-structure"},"Lexical structure"),(0,r.kt)("p",null,"You can skip ","[Lexical structure]"," part and just move to ",(0,r.kt)("a",{parentName:"p",href:"#intro"},"Intro"),"."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Jacy")," might be easy to read for users familiar with C-like syntax. Its syntax is influenced by Rust, Swift, and C++.\nAnyway, some things might be uncommon especially for users not coming from Rust, and I'll try to explain everything as clean as I can."),(0,r.kt)("p",null,"This part is about Lexical structure, that is further, talking about syntax I will refer to particular syntax units, e.g. Identifiers."),(0,r.kt)("h3",{id:"comments"},"Comments"),(0,r.kt)("p",null,"Comments are syntax units that are ignored and do not affect program compilation.\nYou can use them for any additional info and documentation for your code.\n",(0,r.kt)("em",{parentName:"p"},"Jacy")," has C-style comments, ",(0,r.kt)("inlineCode",{parentName:"p"},"//")," for one-line and ",(0,r.kt)("inlineCode",{parentName:"p"},"/**/")," for multiline.\nDocumentation comments start with ",(0,r.kt)("inlineCode",{parentName:"p"},"///")," for one-line and ",(0,r.kt)("inlineCode",{parentName:"p"},"/**")," for multiline (with closing ",(0,r.kt)("inlineCode",{parentName:"p"},"*/"),")"),(0,r.kt)("h3",{id:"identifiers"},"Identifiers"),(0,r.kt)("p",null,"Identifiers in ",(0,r.kt)("em",{parentName:"p"},"Jacy")," start with an English letter or ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," (underscore) followed by ",(0,r.kt)("inlineCode",{parentName:"p"},"_"),", letters or digits.\nIdentifiers are used as names and cannot be the same as reserved words (keywords), which are listed below."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Anyway, in ",(0,r.kt)("em",{parentName:"strong"},"Jacy")," ",(0,r.kt)("inlineCode",{parentName:"strong"},"_")," is a reserved keyword")),(0,r.kt)("p",null,"Examples of valid identifiers: ",(0,r.kt)("inlineCode",{parentName:"p"},"text"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"_123"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"__someStrangeName"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"snake_style_name")),(0,r.kt)("h3",{id:"keywords"},"Keywords"),(0,r.kt)("p",null,"This words are keywords, thus cannot be used as identifiers: ",(0,r.kt)("inlineCode",{parentName:"p"},"and"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"as"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"async"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"await"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"break"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"const"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"continue"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"elif"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"else"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"enum"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"for"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"func"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"if"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"impl"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"in"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"infix"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"init"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"loop"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"match"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"mod"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"move"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"mut"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"not"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"of"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"or"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"return"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"party"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"pub"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ref"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"self"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"static"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"struct"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"super"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"trait"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"type"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"use"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"let"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"where"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"while"),"."),(0,r.kt)("p",null,"There're also reserved keywords that are not in use: ",(0,r.kt)("inlineCode",{parentName:"p"},"do"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"import"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"macro"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"of"),"."),(0,r.kt)("h3",{id:"operators"},"Operators"),(0,r.kt)("p",null,"Operators are special symbols that you use to work with values.\nThere're three kinds of operators: prefix (unary), infix (binary), and postfix (unary).\nPrefix, infix, and postfix are about where an operator is placed: before, between, or after expression(s)."),(0,r.kt)("p",null,"Infix operators have some properties: precedence and associativity."),(0,r.kt)("p",null,"Precedence is a strength of operator, for example, we all know that ",(0,r.kt)("inlineCode",{parentName:"p"},"a + b * c")," is the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"a + (b * c)"),", as ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," operator in math is stronger than ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator."),(0,r.kt)("p",null,"Associativity is about how operators with the same precedence are grouped, that is, if ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator is left-associative, then ",(0,r.kt)("inlineCode",{parentName:"p"},"a + b + c")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"(a + b) + c")," and if it is right-associative then ",(0,r.kt)("inlineCode",{parentName:"p"},"a + (b + c)"),".\nMost infix operators are left-associative."),(0,r.kt)("p",null,"Prefix and postfix operators in ",(0,r.kt)("em",{parentName:"p"},"Jacy")," all have one precedence by groups: postfix is stronger than prefix operator."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Custom operators [future feature]"),(0,r.kt)("blockquote",null,"Is is planned to add custom operators in the future, likely it will be similar to how Swift does it. Anyway, the first versions won't allow customizing operators.")),(0,r.kt)("h4",{id:"operator-precedence-table"},"Operator precedence table"),(0,r.kt)(l.ZP,{mdxType:"PrecedenceTable"}),(0,r.kt)("h4",{id:"not-prefix"},(0,r.kt)("inlineCode",{parentName:"h4"},"not")," prefix"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Jacy")," has a special feature -- you can put ",(0,r.kt)("inlineCode",{parentName:"p"},"not")," operator before infix operator to negate boolean operation.\nExample: ",(0,r.kt)("inlineCode",{parentName:"p"},"a not in b")," is the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"not (a in b)"),".\nThis is useful for operators like ",(0,r.kt)("inlineCode",{parentName:"p"},"in"),", by the way, it is possible to write something like ",(0,r.kt)("inlineCode",{parentName:"p"},"a not and b")," that would be the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"not (a and b)"),", but code like this is hard to read."),(0,r.kt)("p",null,"Of course, when you write ",(0,r.kt)("inlineCode",{parentName:"p"},"a not OP b")," you got ",(0,r.kt)("inlineCode",{parentName:"p"},"not (a OP b)")," thus keep in mind that ",(0,r.kt)("inlineCode",{parentName:"p"},"OP")," must be a logical operator, otherwise you'll have a type error."),(0,r.kt)("h3",{id:"punctuation"},"Punctuation"),(0,r.kt)("p",null,"Some symbols are reserved punctuations, punctuations differ from operators in the sense that operators, obviously, perform some operations, whereas punctuations are used as syntax units: delimiters, disambiguators, etc."),(0,r.kt)("p",null,"Also, some symbols depend on the context, sometimes they can be operators, sometimes punctuations. E.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"=")," is an assignment operator, but only in expressions, for function definition, we use ",(0,r.kt)("inlineCode",{parentName:"p"},"=")," as body beginning (in expression-body case)."),(0,r.kt)("p",null,"Symbols considered punctuations: ",(0,r.kt)("inlineCode",{parentName:"p"},"("),", ",(0,r.kt)("inlineCode",{parentName:"p"},")"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"["),", ",(0,r.kt)("inlineCode",{parentName:"p"},"]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"{"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"}"),", ",(0,r.kt)("inlineCode",{parentName:"p"},","),", ",(0,r.kt)("inlineCode",{parentName:"p"},";"),", ",(0,r.kt)("inlineCode",{parentName:"p"},":"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,r.kt)("inlineCode",{parentName:"p"},">"),' (in generics, not "less/greater than" operators).'),(0,r.kt)("h2",{id:"intro"},"Intro"),(0,r.kt)("p",null,'Let\'s begin with the clich\xe9 -- "Hello, world" in ',(0,r.kt)("em",{parentName:"p"},"Jacy"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jc"},'func main {\n    print("Hello, world");\n}\n')),(0,r.kt)("p",null,"Here you can see:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Functions in ",(0,r.kt)("em",{parentName:"li"},"Jacy")," are defined with ",(0,r.kt)("inlineCode",{parentName:"li"},"func")," keyword."),(0,r.kt)("li",{parentName:"ul"},"Parentheses are omitted -- if a function expects 0 parameters you're able not to write parentheses."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Jacy")," requires semicolons as a statement terminator."),(0,r.kt)("li",{parentName:"ul"},"There's a ",(0,r.kt)("inlineCode",{parentName:"li"},"main")," function, that is, the entry point of the program, as in many other compiled programming languages.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Optional semicolons"),(0,r.kt)("blockquote",null,"You may notice that in _Jacy_ semicolon is a required terminator for statements. In the first version, it would be so, anyway semicolon inference would be one of the first updates in future versions though.")),(0,r.kt)("p",null,"As we already started with a function, let's talk about them right after the introduction to literals."),(0,r.kt)("h3",{id:"primitive-types--literals"},"Primitive types & Literals"),(0,r.kt)("p",null,"Primitive types in ",(0,r.kt)("em",{parentName:"p"},"Jacy"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"boolean type: ",(0,r.kt)("inlineCode",{parentName:"li"},"bool"),"."),(0,r.kt)("li",{parentName:"ul"},"character type ",(0,r.kt)("inlineCode",{parentName:"li"},"char"),"."),(0,r.kt)("li",{parentName:"ul"},"signed integer types: ",(0,r.kt)("inlineCode",{parentName:"li"},"i8"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"i16"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"i32"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"i64")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"int"),"."),(0,r.kt)("li",{parentName:"ul"},"unsigned integer types: ",(0,r.kt)("inlineCode",{parentName:"li"},"u8"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"u16"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"u32"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"u64")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"uint"),"."),(0,r.kt)("li",{parentName:"ul"},"floating-point number types: ",(0,r.kt)("inlineCode",{parentName:"li"},"f32")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"f64"),"."),(0,r.kt)("li",{parentName:"ul"},"slice type: ",(0,r.kt)("inlineCode",{parentName:"li"},"[T]"),"."),(0,r.kt)("li",{parentName:"ul"},"string slice type: ",(0,r.kt)("inlineCode",{parentName:"li"},"str"),"."),(0,r.kt)("li",{parentName:"ul"},"tuple type: ",(0,r.kt)("inlineCode",{parentName:"li"},"(T1, T2, T3, ...)")),(0,r.kt)("li",{parentName:"ul"},"array type: ",(0,r.kt)("inlineCode",{parentName:"li"},"[T; N]"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Type naming"),(0,r.kt)("blockquote",null,"Despite the names of primitive type, in _Jacy_, by convention, type names must begin with an upper-case letter. Primitive type names are exceptions, you must use PascalCase (capitalized camelCase) for type names.")),(0,r.kt)("h4",{id:"boolean"},"Boolean"),(0,r.kt)("p",null,"The boolean type can hold one of two values: ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("h4",{id:"character"},"Character"),(0,r.kt)("p",null,"In ",(0,r.kt)("em",{parentName:"p"},"Jacy")," characters are always valid, utf8 encoded Unicode points, thus the size of one character is 4 bytes.\nIn contrast to Rust, C, C++, and other languages that have character literal, in ",(0,r.kt)("em",{parentName:"p"},"Jacy"),", you character literal is written in the same way as a string literal (as in Swift)."),(0,r.kt)("p",null,"So, ",(0,r.kt)("inlineCode",{parentName:"p"},'"a"')," can be a character, but ",(0,r.kt)("inlineCode",{parentName:"p"},'"abcde"'),' cannot, because it holds multiple characters (it is a string).\nThe question that you may come with is "How do I say that it is a character" -- you need to annotate the type of expression, depending on the context.\nFor variables, you need to write ',(0,r.kt)("inlineCode",{parentName:"p"},'let a: char = "a"'),", but for function, you can just pass character without any annotation ",(0,r.kt)("inlineCode",{parentName:"p"},'foo("a")')," if function expects ",(0,r.kt)("inlineCode",{parentName:"p"},"char")," as the first argument."),(0,r.kt)("h4",{id:"integer-types"},"Integer types"),(0,r.kt)("p",null,"Integer types in ",(0,r.kt)("em",{parentName:"p"},"Jacy")," exist in 4 static sizes: 8, 16, 32, and 64-bit size, and two kinds - signed and unsigned.\nThe types ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"uint")," are platform-dependent types, in Rust, they are the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"isize")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"usize")," respectively."),(0,r.kt)("p",null,"By default, integer literal is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),".\nTo create an integer literal of a specific type, you can use a type suffix same as a type name, e.g. for ",(0,r.kt)("inlineCode",{parentName:"p"},"u8")," typed integer ",(0,r.kt)("inlineCode",{parentName:"p"},"123")," you write ",(0,r.kt)("inlineCode",{parentName:"p"},"123u8"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"`i128` and `u128`"),(0,r.kt)("blockquote",null,"As you can see, there is no 128-bit sized integer type in _Jacy_ for now, by the way, they are in the future plan.")),(0,r.kt)("h4",{id:"floating-point-types"},"Floating point types"),(0,r.kt)("p",null,"For floating-point numbers, there're two types: ",(0,r.kt)("inlineCode",{parentName:"p"},"f32")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"f64")," - 32-bit sized and 64-bit sized respectively."),(0,r.kt)("p",null,"Float literals support suffixes too as int's: ",(0,r.kt)("inlineCode",{parentName:"p"},"1.6783f32")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"55f64"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"`f128`"),(0,r.kt)("blockquote",null,"As 128-bit integers, `f128` is in the future plan.")),(0,r.kt)("h4",{id:"slice-type"},"Slice type"),(0,r.kt)("p",null,'If you have no experience with Rust, slice type might be hard to comprehend. Slice is a kind of "view" into memory where data is placed, it is statically sized but the size is not unknown at compile-time.\nIn C, a slice would be the same as pointer + size, like ',(0,r.kt)("inlineCode",{parentName:"p"},"char * arr; int size"),". While in C you can access any address you want and you pass a size everywhere to know how many elements you have access to. In ",(0,r.kt)("em",{parentName:"p"},"Jacy")," it is impossible (without hack-like code) to access invalid memory locations."),(0,r.kt)("p",null,'Don\'t confuse "slice" in ',(0,r.kt)("em",{parentName:"p"},"Jacy")," with a slice of the list, etc. in other programming languages, while concepts are pretty relative."),(0,r.kt)("p",null,"Slice type is a type enclosed into brackets - ",(0,r.kt)("inlineCode",{parentName:"p"},"[T]"),", e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"[int]"),' is an "int slice".'),(0,r.kt)("h4",{id:"str--string-slice-type"},(0,r.kt)("inlineCode",{parentName:"h4"},"str")," / String Slice type"),(0,r.kt)("p",null,"There's one specific kind of slice that is used so often thus got his own type -- ",(0,r.kt)("inlineCode",{parentName:"p"},"str"),".\nIt is simply a string slice, pretty same as ",(0,r.kt)("inlineCode",{parentName:"p"},"[char]"),"."),(0,r.kt)("h4",{id:"tuple-type"},"Tuple type"),(0,r.kt)("p",null,"Tuple is a heterogeneous collection, i.e. collection of different types. Tuple elements do not have names and can be accessed by index, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"(123, 666).0")," will be ",(0,r.kt)("inlineCode",{parentName:"p"},"123"),"."),(0,r.kt)("h5",{id:"unit-type"},"Unit type"),(0,r.kt)("p",null,"Unit type is an empty tuple - ",(0,r.kt)("inlineCode",{parentName:"p"},"()"),", its purpose is the same as of ",(0,r.kt)("inlineCode",{parentName:"p"},"void")," in some programming languages.\nBy default, if type omitted - functions return ",(0,r.kt)("inlineCode",{parentName:"p"},"()"),"."),(0,r.kt)("h4",{id:"array-type"},"Array type"),(0,r.kt)("p",null,"Array is a homogeneous collection, i.e. all elements are of the same type. Arrays have static compile-time-known size, so you cannot resize it."),(0,r.kt)("p",null,"Array type looks like slice type but with size, ascription after ",(0,r.kt)("inlineCode",{parentName:"p"},";")," - ",(0,r.kt)("inlineCode",{parentName:"p"},"[T; N]"),", e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"[int; 100]")," is an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"100")," ints."),(0,r.kt)("h3",{id:"functions"},"Functions"),(0,r.kt)("p",null,"You can declare a function with ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," keyword followed by its name, parameters, and body (there're also some more particles but we'll review them further)."),(0,r.kt)("p",null,"Let's disassemble a simple function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jc"},"func add(a: int, b: int): int {\n    return a + b;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(a: int, b: int)")," is a parameter list where ",(0,r.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"b")," are names of parameters and ",(0,r.kt)("inlineCode",{parentName:"li"},"int"),"'s are types for each of them."),(0,r.kt)("li",{parentName:"ul"},"After the parameter list goes return type, it is annotated with the same punctuation - ",(0,r.kt)("inlineCode",{parentName:"li"},":")),(0,r.kt)("li",{parentName:"ul"},"Function body is enclosed into ",(0,r.kt)("inlineCode",{parentName:"li"},"{}"),' (curly brackets, also I\'ll probably call them "braces" further)')),(0,r.kt)("p",null,"To invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," we need to pass two integers in it -- ",(0,r.kt)("inlineCode",{parentName:"p"},"add(1, 2)"),", this expression will result in integer ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),"."),(0,r.kt)("h4",{id:"invocations-with-labels"},"Invocations with labels"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Jacy")," supports labeled arguments, it is a way to call a function without writing arguments in the same order as parameters are declared."),(0,r.kt)("p",null,"Let's call ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," function from example above with named arguments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jc"},"add(a: 6, b: 13); // 19\nadd(b: 13, a: 6); // 19. Order does not matter\n")),(0,r.kt)("h4",{id:"function-overloading"},"Function overloading"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Jacy")," does not support type function overloading, but you can overload function with different parameter labels."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jc"},"func add(intA: int, intB: int): int {\n    return intA + intB;\n}\n\nfunc add(floatA: f64, floatB: f64): f64 {\n    return floatA + floatB;\n}\n")),(0,r.kt)("h3",{id:"structures"},"Structures"),(0,r.kt)("p",null,"Structures in ",(0,r.kt)("em",{parentName:"p"},"Jacy")," are declared the same way as in Rust:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jc"},"struct MyStruct {\n    field: i32,\n}\n")),(0,r.kt)("h3",{id:"traits"},"Traits"),(0,r.kt)("p",null,"Traits are also similar to Rust:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jc"},"trait DoesSmth {\n    func doSmth();\n}\n")))}k.isMDXComponent=!0},1734:function(e,t,n){n.d(t,{ZP:function(){return p}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],o={toc:[]};function p(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'This table shows which operators are stronger than others, associativity is marked as "left to right" for left-associative operators and "right to left" for right-associative operators.\nThis table also includes expressions that are not operator expressions, anyway, it might be helpful to know that they are parsed assuming this figurative precedence.'),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Precedence index is placed just for some help, sometimes you need to know the order.")),(0,r.kt)("p",null,"The table is from high to low precedence ordered -- the operators in the first row have the strongest precedence."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Non-Assoc means non-associative operator, i.e. it is not allowed to combine it with itself like so ",(0,r.kt)("inlineCode",{parentName:"p"},"a OP b OP c"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"N"),(0,r.kt)("th",{parentName:"tr",align:null},"Operator groups / expressions"),(0,r.kt)("th",{parentName:"tr",align:null},"Associativity"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"Paths (",(0,r.kt)("inlineCode",{parentName:"td"},"::"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"19"),(0,r.kt)("td",{parentName:"tr",align:null},"Field expression (aka member access - ",(0,r.kt)("inlineCode",{parentName:"td"},"a.b"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"left to right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"18"),(0,r.kt)("td",{parentName:"tr",align:null},"Invocations (aka calls - ",(0,r.kt)("inlineCode",{parentName:"td"},"a(...)"),"), array access (aka indexing - ",(0,r.kt)("inlineCode",{parentName:"td"},"a[...]"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"[Postfix operators]"," ",(0,r.kt)("inlineCode",{parentName:"td"},"?")),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"[Prefix operators]"," ",(0,r.kt)("inlineCode",{parentName:"td"},"!"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"&"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"&mut"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"-"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},"N/A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"15"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"as")),(0,r.kt)("td",{parentName:"tr",align:null},"left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"14"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")," ",(0,r.kt)("inlineCode",{parentName:"td"},"/")," ",(0,r.kt)("inlineCode",{parentName:"td"},"%")),(0,r.kt)("td",{parentName:"tr",align:null},"left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"13"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"+")," ",(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:null},"left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"12"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"..")," ",(0,r.kt)("inlineCode",{parentName:"td"},"..=")),(0,r.kt)("td",{parentName:"tr",align:null},"non-assoc")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"11"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<<")," ",(0,r.kt)("inlineCode",{parentName:"td"},">>")),(0,r.kt)("td",{parentName:"tr",align:null},"left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&")," (infix)"),(0,r.kt)("td",{parentName:"tr",align:null},"left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"9"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"^")),(0,r.kt)("td",{parentName:"tr",align:null},"left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\u2223")),(0,r.kt)("td",{parentName:"tr",align:null},"left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"7"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"in")),(0,r.kt)("td",{parentName:"tr",align:null},"non-assoc")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<=>")),(0,r.kt)("td",{parentName:"tr",align:null},"non-assoc")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<")," ",(0,r.kt)("inlineCode",{parentName:"td"},">")," ",(0,r.kt)("inlineCode",{parentName:"td"},"<=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"=>")),(0,r.kt)("td",{parentName:"tr",align:null},"non-assoc")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"==")," ",(0,r.kt)("inlineCode",{parentName:"td"},"!=")),(0,r.kt)("td",{parentName:"tr",align:null},"non-assoc")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"and")),(0,r.kt)("td",{parentName:"tr",align:null},"left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"or")),(0,r.kt)("td",{parentName:"tr",align:null},"left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"+=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"-=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"*=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"/=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"%=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"&=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"\u2223=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"^=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"<<=")," ",(0,r.kt)("inlineCode",{parentName:"td"},">>=")),(0,r.kt)("td",{parentName:"tr",align:null},"left")))),(0,r.kt)("p",null,"Prefix operators: ",(0,r.kt)("inlineCode",{parentName:"p"},"not"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," (borrow), ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut")," (borrow as mutable, ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mut")," can have whitespace between), ",(0,r.kt)("inlineCode",{parentName:"p"},"-")," (negation), ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," (dereference)."),(0,r.kt)("p",null,"Postfix operators: ",(0,r.kt)("inlineCode",{parentName:"p"},"?")," (optional chaining), ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," (unwrap)."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Range operators precedence [why?]"),(0,r.kt)("blockquote",null,"Range operators have this kind of precedence as we want to write `a..b+1` which means `a..(b+1)` as far as writing `a..b == c..d` which means `(a..b) == (c..d)`")))}p.isMDXComponent=!0}}]);