"use strict";(self.webpackChunkdev_book=self.webpackChunkdev_book||[]).push([[4629],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return b}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=u(a),b=r,d=m["".concat(s,".").concat(b)]||m[b]||c[b]||l;return a?n.createElement(d,o(o({ref:t},p),{},{components:a})):n.createElement(d,o({ref:t},p))}));function b(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var u=2;u<l;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},92587:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return p},default:function(){return m}});var n=a(87462),r=a(63366),l=(a(67294),a(3905)),o=["components"],i={sidebar_position:40},s="Taxonomy and glossary",u={unversionedId:"appendices/taxonomy-&-glossary",id:"appendices/taxonomy-&-glossary",isDocsHomePage:!1,title:"Taxonomy and glossary",description:"Permissions",source:"@site/docs/appendices/taxonomy-&-glossary.md",sourceDirName:"appendices",slug:"/appendices/taxonomy-&-glossary",permalink:"/dev-book/docs/appendices/taxonomy-&-glossary",editUrl:"https://github.com/jacylang/dev-book/edit/master/docs/appendices/taxonomy-&-glossary.md",tags:[],version:"current",sidebarPosition:40,frontMatter:{sidebar_position:40},sidebar:"tutorialSidebar",previous:{title:"Operators and punctuations",permalink:"/dev-book/docs/appendices/ops-and-puncts"},next:{title:"Programming Language Checklist \ud83d\ude05",permalink:"/dev-book/docs/appendices/checklist"}},p=[{value:"Permissions",id:"permissions",children:[{value:"Mutability",id:"mutability",children:[],level:3},{value:"Aliasing",id:"aliasing",children:[],level:3},{value:"Combinations",id:"combinations",children:[],level:3},{value:"Mutable/Immutable + Linear",id:"mutableimmutable--linear",children:[],level:3},{value:"Mutable + Locally sharable",id:"mutable--locally-sharable",children:[],level:3},{value:"Mutable + Globally sharable",id:"mutable--globally-sharable",children:[],level:3},{value:"Immutable + Locally/Globally sharable",id:"immutable--locallyglobally-sharable",children:[],level:3},{value:"Opaque",id:"opaque",children:[],level:3},{value:"Borrowed references",id:"borrowed-references",children:[],level:3}],level:2}],c={toc:p};function m(e){var t=e.components,a=(0,r.Z)(e,o);return(0,l.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"taxonomy-and-glossary"},"Taxonomy and glossary"),(0,l.kt)("h2",{id:"permissions"},"Permissions"),(0,l.kt)("h3",{id:"mutability"},"Mutability"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Mutable")," - Allows read + write\n",(0,l.kt)("strong",{parentName:"p"},"Immutable")," - Allows only read, disallows write\n",(0,l.kt)("strong",{parentName:"p"},"Opaque")," - Disallows both read and write"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Don't confuse Opaque permission with Rust's opaque types (aka ",(0,l.kt)("inlineCode",{parentName:"p"},"impl Trait"),")")),(0,l.kt)("h3",{id:"aliasing"},"Aliasing"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Linear")," - Disallows aliases\n",(0,l.kt)("strong",{parentName:"p"},"Locally sharable")," - Allows aliases in single-thread\n",(0,l.kt)("strong",{parentName:"p"},"Globally sharable")," - Allows aliases shared between threads"),(0,l.kt)("h3",{id:"combinations"},"Combinations"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Some combinations are merged and some deleted")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"center"},"Mutability"),(0,l.kt)("th",{parentName:"tr",align:"center"},"Aliasing"),(0,l.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"center"},"Mutable/Immutable"),(0,l.kt)("td",{parentName:"tr",align:"center"},"Linear"),(0,l.kt)("td",{parentName:"tr",align:"center"},(0,l.kt)("a",{parentName:"td",href:"#mut-imm-lin"},"#1"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"center"},"Mutable"),(0,l.kt)("td",{parentName:"tr",align:"center"},"Locally sharable"),(0,l.kt)("td",{parentName:"tr",align:"center"},(0,l.kt)("a",{parentName:"td",href:"#mut-loc"},"#2"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"center"},"Mutable"),(0,l.kt)("td",{parentName:"tr",align:"center"},"Globally sharable"),(0,l.kt)("td",{parentName:"tr",align:"center"},(0,l.kt)("a",{parentName:"td",href:"#mut-glob"},"#3"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"center"},"Immutable"),(0,l.kt)("td",{parentName:"tr",align:"center"},"Locally/Globally sharable"),(0,l.kt)("td",{parentName:"tr",align:"center"},(0,l.kt)("a",{parentName:"td",href:"#mut-loc-glob"},"#4"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"center"},"Opaque"),(0,l.kt)("td",{parentName:"tr",align:"center"},"N/A"),(0,l.kt)("td",{parentName:"tr",align:"center"},(0,l.kt)("a",{parentName:"td",href:"#opaque"},"#5"))))),(0,l.kt)("h3",{id:"mutableimmutable--linear"},"Mutable/Immutable + Linear"),(0,l.kt)("p",null,"This is the foundation of Rust -- move semantics.\nExample:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jc"},"let mut a = MyStruct {field: 123};\nlet b = a; // `a` is moved to `b`\nlet mut c = b; // `b` is moved to `c`\n")),(0,l.kt)("p",null,"Linear type is orthogonal to aliasing as it cannot be aliased at all -- it is always moved.\nLinear types allow moving from immutable context to mutable one."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'Actually, it is important to note, that these are not the actual "Linear" types, more likely to say that these are "Affine" types as we don\'t require user to use value (except linter warnings)\nConclusion: ',(0,l.kt)("strong",{parentName:"p"},"APPLIED"))),(0,l.kt)("h3",{id:"mutable--locally-sharable"},"Mutable + Locally sharable"),(0,l.kt)("p",null,"Example (pseudo Pony-like code):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jc"},"let mut a = 123;\nlet mut b = mut ref a;\nlet mut c = b; // `b` is not moved to `c`, `c` re-borrows `a`\n\n// `b` cannot be sent to another thread and can only be used in single one\n")),(0,l.kt)("p",null,"The problem of multiple mutable aliases is that they bring possibility to make a mistake if some code is running concurrently, also, it would be hard (and maybe impossible) to manage such aliases without GC, thus we refuse this concept."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Conclusion: ",(0,l.kt)("strong",{parentName:"p"},"DENIED"))),(0,l.kt)("h3",{id:"mutable--globally-sharable"},"Mutable + Globally sharable"),(0,l.kt)("p",null,"Raw usage is ",(0,l.kt)("strong",{parentName:"p"},"UNSAFE")," as it needs lock functionality."),(0,l.kt)("p",null,"The safe implementation is commonly known as Mutex."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Conclusion: ",(0,l.kt)("strong",{parentName:"p"},"DENIED")," (as first class item without a wrapper)")),(0,l.kt)("h3",{id:"immutable--locallyglobally-sharable"},"Immutable + Locally/Globally sharable"),(0,l.kt)("p",null,"Immutable aliases are safe to share globally, obviously, checking that there're no mutable aliases to them.\nThese are under the Rust borrowing rules."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Conclusion: ",(0,l.kt)("strong",{parentName:"p"},"APPLIED"))),(0,l.kt)("h3",{id:"opaque"},"Opaque"),(0,l.kt)("p",null,'Neither able to read or write to alias. Used for function pointers and other "externally-created" data.'),(0,l.kt)("p",null,"Dividing opaque permission by aliasing is a nonsense as far as it just cannot be read or written to."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Pony calls this ",(0,l.kt)("inlineCode",{parentName:"li"},"iso")),(0,l.kt)("li",{parentName:"ul"},"Cone calls this ",(0,l.kt)("inlineCode",{parentName:"li"},"opaq")),(0,l.kt)("li",{parentName:"ul"},"Rust does not have this (",(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-lang/rfcs/blob/master/text/1861-extern-types.md"},"here is an issue"),")")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Conclusion: ",(0,l.kt)("strong",{parentName:"p"},"?"))),(0,l.kt)("h3",{id:"borrowed-references"},"Borrowed references"),(0,l.kt)("p",null,"Borrowed references obey Rust borrow checker rules:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"There can only exist one mutable or any count of immutable borrows")))}m.isMDXComponent=!0}}]);