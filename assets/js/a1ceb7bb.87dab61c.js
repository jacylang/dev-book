"use strict";(self.webpackChunkdev_book=self.webpackChunkdev_book||[]).push([[1153],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),f=l(n),d=i,y=f["".concat(p,".").concat(d)]||f[d]||u[d]||o;return n?r.createElement(y,a(a({ref:t},c),{},{components:n})):r.createElement(y,a({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=f;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var l=2;l<o;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},34201:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return p},metadata:function(){return l},toc:function(){return c},default:function(){return f}});var r=n(87462),i=n(63366),o=(n(67294),n(3905)),a=["components"],s={},p="Type Ascriptions",l={unversionedId:"particles/type-ascriptions",id:"particles/type-ascriptions",isDocsHomePage:!1,title:"Type Ascriptions",description:"This is a far-from-v1 proposal. Don't even think to add it in first alpha-beta versions.",source:"@site/docs/particles/type-ascriptions.md",sourceDirName:"particles",slug:"/particles/type-ascriptions",permalink:"/dev-book/docs/particles/type-ascriptions",editUrl:"https://github.com/jacylang/dev-book/edit/master/docs/particles/type-ascriptions.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Strings",permalink:"/dev-book/docs/particles/strings"},next:{title:"Blocks",permalink:"/dev-book/docs/particles/syntax-decisions/blocks"}},c=[{value:"The operator",id:"the-operator",children:[{value:"References",id:"references",children:[],level:3}],level:2}],u={toc:c};function f(e){var t=e.components,n=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"type-ascriptions"},"Type Ascriptions"),(0,o.kt)("p",null,'This is a far-from-v1 proposal. Don\'t even think to add it in first alpha-beta versions.\nIt, as many of other particles, exists as I want to keep all ideas in one place, by looking at all of them we can see the whole picture, thus not having any confusions like "the operator OP is used by feature#1 but also has different meaning in feature#2".'),(0,o.kt)("p",null,"Type ascription is a kind of a hint for type inference algorithm which allows us to write qualification for generically-typed expression inlined."),(0,o.kt)("p",null,"For example, we have an expression ",(0,o.kt)("inlineCode",{parentName:"p"},"a.get()")," where ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"func<T> get()"),", the compiler cannot infer the type as it is definitely user-specific, thus we need to qualify it someway. One can think that it is possible by using a variable:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jc"},"let x: Type = a.get()\n\n// The type of `x` is qualified\nx\n")),(0,o.kt)("p",null,"And this is the right solution, anyway, it looks not pretty.\nHow would it look like with type ascriptions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jc"},"let x = a.get(): Type\n")),(0,o.kt)("p",null,"To finally sign of on type ascriptions, let's consider a more useful case:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jc"},"someMethod({\n    let x: Type = a.get()\n    x\n})\n")),(0,o.kt)("p",null,"Here, in block expression, we need to introduce a variable to qualify the type of result given by ",(0,o.kt)("inlineCode",{parentName:"p"},"a.get()"),". Being straightforward, this syntax looks overloaded.\nWith type ascriptions it will be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jc"},"someMethod(a.get(): Type)\n")),(0,o.kt)("h2",{id:"the-operator"},"The operator"),(0,o.kt)("p",null,"Rust has an RFC for this, where symbol ",(0,o.kt)("inlineCode",{parentName:"p"},":")," is used for type ascriptions.\nThis solution is not bad, even solid as we use ",(0,o.kt)("inlineCode",{parentName:"p"},":")," for type annotations.\nAnyway, I need to check out if it collides with other purposes, and, as I remember, I've already thought to use ",(0,o.kt)("inlineCode",{parentName:"p"},"of")," as keyword for type ascriptions because ",(0,o.kt)("inlineCode",{parentName:"p"},":")," had different meaning in expressions."),(0,o.kt)("h3",{id:"references"},"References"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/rfcs/0803-type-ascription.html"},"Rust proposal")))}f.isMDXComponent=!0}}]);