"use strict";(self.webpackChunkdev_book=self.webpackChunkdev_book||[]).push([[7317],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return y}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(r),y=a,f=p["".concat(l,".").concat(y)]||p[y]||m[y]||o;return r?n.createElement(f,i(i({ref:t},u),{},{components:r})):n.createElement(f,i({ref:t},u))}));function y(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},5468:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var n=r(7462),a=r(3366),o=(r(7294),r(3905)),i=["components"],s={},l="Memory leaks",c={unversionedId:"particles/memory-leaks",id:"particles/memory-leaks",isDocsHomePage:!1,title:"Memory leaks",description:"What are memory leaks and how do we prevent them and should we?",source:"@site/docs/particles/memory-leaks.md",sourceDirName:"particles",slug:"/particles/memory-leaks",permalink:"/dev-book/docs/particles/memory-leaks",editUrl:"https://github.com/jacylang/dev-book/edit/master/docs/particles/memory-leaks.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Particles",permalink:"/dev-book/docs/particles/index"},next:{title:"`not` prependent operator",permalink:"/dev-book/docs/particles/not-prepedent-op"}},u=[{value:"Cause",id:"cause",children:[],level:2},{value:"ARC as first-class entity",id:"arc-as-first-class-entity",children:[],level:2}],m={toc:u};function p(e){var t=e.components,r=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"memory-leaks"},"Memory leaks"),(0,o.kt)("p",null,"What are memory leaks and how do we prevent them and should we?"),(0,o.kt)("h2",{id:"cause"},"Cause"),(0,o.kt)("p",null,'In languages like C or C++ memory leaks can exist in a code in any way, it is not what we actually interested in. The question is -- can we help user avoid memory leaks?\nIn languages with automatic memory management memory leaks can still exist, and it can be not a user fault, V8 GC can have some troubles when, for example, code uses closures.\nGC is not really interesting for me (tracing GC). Rust does not have GC at all and isn\'t built on any GC-like concept like Swift (that uses ARC) -- memory is managed statically (if we are talking about references).\nMemory leaks with references are not possible in Rust as it would break the whole theory of its safety, by the way, ML can be caused by cyclic Rc without Weak break or when we use unsafe pointers, for example, in FFI.\nActually, FFI kind of "requires" memory leaks as if memory is fully managed by the language, it is impossible to say it: "this memory gonna be used externally by C program", thus we need to be able to leave memory out of control.'),(0,o.kt)("h2",{id:"arc-as-first-class-entity"},"ARC as first-class entity"),(0,o.kt)("p",null,"I want to disassemble an idea of first-class ARC. The reason to have ARC as first-class entity is an ability to statically check wherever a problem like cyclic references occur and may cause a memory leak."))}p.isMDXComponent=!0}}]);