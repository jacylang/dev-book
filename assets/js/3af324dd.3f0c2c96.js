"use strict";(self.webpackChunkdev_book=self.webpackChunkdev_book||[]).push([[1733],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return d}});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),u=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=u(e.components);return a.createElement(p.Provider,{value:n},e.children)},s={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=u(t),d=r,N=c["".concat(p,".").concat(d)]||c[d]||s[d]||i;return t?a.createElement(N,l(l({ref:n},m),{},{components:t})):a.createElement(N,l({ref:n},m))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=c;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var u=2;u<i;u++)l[u]=t[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},49902:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return u},toc:function(){return m},default:function(){return c}});var a=t(87462),r=t(63366),i=(t(67294),t(3905)),l=["components"],o={sidebar_position:1,title:"Specification"},p="_JON_ Specificiation",u={unversionedId:"jon/spec",id:"jon/spec",isDocsHomePage:!1,title:"Specification",description:"JON (Jacy Object Notation, ext.: .jon) is an alternative for JSON used by Jacy programming language.",source:"@site/docs/jon/spec.md",sourceDirName:"jon",slug:"/jon/spec",permalink:"/dev-book/docs/jon/spec",editUrl:"https://github.com/jacylang/dev-book/edit/master/docs/jon/spec.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Specification"},sidebar:"tutorialSidebar",previous:{title:"Intro",permalink:"/dev-book/docs/appendices/spec/intro"},next:{title:"Compiler FAQ",permalink:"/dev-book/docs/compiler-faq"}},m=[{value:"Why <em>JON</em>?",id:"why-jon",children:[],level:2},{value:"Basic properties",id:"basic-properties",children:[{value:"Root type",id:"root-type",children:[],level:3}],level:2},{value:"Data types",id:"data-types",children:[{value:"Numeric data types",id:"numeric-data-types",children:[],level:3}],level:2},{value:"Grammar",id:"grammar",children:[],level:2}],s={toc:m};function c(e){var n=e.components,t=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"jon-specificiation"},(0,i.kt)("em",{parentName:"h1"},"JON")," Specificiation"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"JON")," (Jacy Object Notation, ext.: ",(0,i.kt)("inlineCode",{parentName:"p"},".jon"),") is an alternative for JSON used by ",(0,i.kt)("em",{parentName:"p"},"Jacy")," programming language.\nIts goals are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Simpler and less noisy syntax"),(0,i.kt)("li",{parentName:"ul"},"Data referencing")),(0,i.kt)("p",null,'Though this page is called "Specification", better think of it as of grammar description.'),(0,i.kt)("h2",{id:"why-jon"},"Why ",(0,i.kt)("em",{parentName:"h2"},"JON"),"?"),(0,i.kt)("p",null,'Spoiler: No clear reasons, I just like creating "my" things.'),(0,i.kt)("p",null,"JSON is a very popular format used almost everywhere, so why do we need a different format?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It is more liberal than JSON but still obvious and simple"),(0,i.kt)("li",{parentName:"ul"},"It is more human friendly but not that hard as YAML"),(0,i.kt)("li",{parentName:"ul"},"It is more complex than JSON, in a good way \ud83d\ude07")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"JON")," was also made as an alternative to TOML, as ",(0,i.kt)("em",{parentName:"p"},"Jacy")," is similar to ",(0,i.kt)("strong",{parentName:"p"},"Rust")," that uses TOML.\nI don't really like TOML \ud83d\ude10."),(0,i.kt)("h2",{id:"basic-properties"},"Basic properties"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"JON")," is case-sensitive, it this rule is applied to keywords too")),(0,i.kt)("h3",{id:"root-type"},"Root type"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"JON")," does not support root type specification as JSON does, there's no root ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),", and a ",(0,i.kt)("em",{parentName:"p"},"JON")," file is always an object."),(0,i.kt)("h2",{id:"data-types"},"Data types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," (non-value)"),(0,i.kt)("li",{parentName:"ul"},"Boolean - ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"false")),(0,i.kt)("li",{parentName:"ul"},"Integer",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Decimal - ",(0,i.kt)("inlineCode",{parentName:"li"},"123")),(0,i.kt)("li",{parentName:"ul"},"Hexadecimal - ",(0,i.kt)("inlineCode",{parentName:"li"},"0xB16B00B5")),(0,i.kt)("li",{parentName:"ul"},"Octal - ",(0,i.kt)("inlineCode",{parentName:"li"},"0o774")),(0,i.kt)("li",{parentName:"ul"},"Binary - ",(0,i.kt)("inlineCode",{parentName:"li"},"0b110011001")))),(0,i.kt)("li",{parentName:"ul"},"Floating-point numbers",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Raw - ",(0,i.kt)("inlineCode",{parentName:"li"},"0.1523")),(0,i.kt)("li",{parentName:"ul"},"With exponential notation - ",(0,i.kt)("inlineCode",{parentName:"li"},"0.123213e-123")))),(0,i.kt)("li",{parentName:"ul"},"Strings",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"One line - ",(0,i.kt)("inlineCode",{parentName:"li"},"'Hello, world!'")," and ",(0,i.kt)("inlineCode",{parentName:"li"},'"Hello, world!"')," are same"),(0,i.kt)("li",{parentName:"ul"},"Multi-line - ",(0,i.kt)("inlineCode",{parentName:"li"},"'''My multiline string'''")," and ",(0,i.kt)("inlineCode",{parentName:"li"},'"""My multiline string"""')," are same"))),(0,i.kt)("li",{parentName:"ul"},"Arrays",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Collection of values enclosed into ",(0,i.kt)("inlineCode",{parentName:"li"},"[]")," and delimited with ",(0,i.kt)("inlineCode",{parentName:"li"},",")," (optionally, read further)"),(0,i.kt)("li",{parentName:"ul"},"Arrays are heterogeneous"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, 'Some text here', null, true]")))),(0,i.kt)("li",{parentName:"ul"},"Objects",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Collection of key-value pairs enclosed into ",(0,i.kt)("inlineCode",{parentName:"li"},"{}")," and delimited by ",(0,i.kt)("inlineCode",{parentName:"li"},",")," (optionally, read further)"),(0,i.kt)("li",{parentName:"ul"},"Each pair is ",(0,i.kt)("inlineCode",{parentName:"li"},"key: value")," where",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key")," is any text and does not require being enclosed into quotes (",(0,i.kt)("inlineCode",{parentName:"li"},"'")," or ",(0,i.kt)("inlineCode",{parentName:"li"},'"'),") until it does not contain ",(0,i.kt)("inlineCode",{parentName:"li"},":")," character")))))),(0,i.kt)("h3",{id:"numeric-data-types"},"Numeric data types"),(0,i.kt)("p",null,'There\'s no limit to Integer ("int" further) and Floating-point ("float" further) numbers, and is only specified by implementation.'),(0,i.kt)("h2",{id:"grammar"},"Grammar"),(0,i.kt)("p",null,"Here, I'll use ANTLR4 grammar as it is more readable than EBNF."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-g4"},"grammar: JON;\n\nroot: object_body | value;\n\nkey: literal | IDENT;\n\nIDENT: IDENTIFIER_START IDENTIFIER_NEXT*;\n\nvalue: literal | object | array;\n\nliteral\n    : STRING\n    | 'null'\n    | number\n    | bool;\n\nnumber: int | float;\n\nint\n    : DEC_LIT\n    | '0' [xX] (HEX | US)* HEX (HEX | US)*\n    | '0' [bB] (BIN | US)* BIN (BIN | US)*\n    | '0' [oO] (OCT | US)* OCT (OCT | US)*;\n\nfragment DEC_LIT: '0' | DEC (DEC | US)*;\n\nfloat\n    : DEC_LIT EXP\n    | DEC_LIT '.' DEC_LIT EXP?\n    | SIGN? 'nan'\n    | SIGN? 'inf';\n\nfragment EXP: [eE] SIGN? (DEC | US)* DEC (DEC | US)*;\n\nkey_value: key opt_nls ':' opt_nls value;\n\nopt_nls: NLs*;\nsep: '\\n'+ | opt_nls ',' opt_nls;\n\nobject_body: key_value (sep key_value)* sep?;\nobject: '{' opt_nls object_body? opt_nls '}';\n\narray: '[' (value (sep? value)* sep?)? ']';\n\nfragment US: '_'\n\nfragment DEC: [0-9];\nfragment HEX: [0-9a-fA-F];\nfragment OCT: [0-7];\nfragment BIN: [01];\n\nfragment SIGN: '-' | '+';\n\nfragment STRING\n    : '\\'' (~['\\\\\\u0000-\\u001F] | STR_ESC | ('\\\\\\'')) '\\''\n    | '\"' (~[\"\\\\\\u0000-\\u001F] | STR_ESC | ('\\\\\"')) '\"'\n    | '\\'\\'\\'' (~['\\\\\\u0000-\\u001F] | STR_ESC | ('\\\\\\'')) '\\'\\'\\''\n    | '\"\"\"' (~[\"\\\\\\u0000-\\u001F] | STR_ESC | ('\\\\\"')) '\"\"\"';\n\nfragment STR_ESC\n    : '\\\\'\n    ( [\\\\/bnfrt0]\n    | OCT OCT OCT\n    | 'x' HEX HEX\n    | 'u' HEX HEX\n    | 'U' HEX HEX HEX HEX);\n\nfragment IDENTIFIER_START\n    : [\\p{L}]\n    | '_';\n\nfragment IDENTIFIER_NEXT\n    : IDENTIFIER_START\n    | [\\p{M}]\n    | [\\p{N}]\n    | [\\p{Pc}]\n    | '\\u200C'\n    | '\\u200D';\n\nfragment NL\n   : '\\r\\n'\n   | [\\r\\n\\u2028\\u2029]\n\nfragment MULTILINE_COMMENT: '/*' .*? '*/' -> skip;\n\nfragment SINGLE_LINE_COMMENT: '//' .*? '*/' -> skip;\n\nWS: [ \\t\\r\\u00A0\\uFEFF\\u2003]+ -> skip;\n")))}c.isMDXComponent=!0}}]);