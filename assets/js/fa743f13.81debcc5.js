"use strict";(self.webpackChunkdev_book=self.webpackChunkdev_book||[]).push([[7554],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function d(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var r=i.createContext({}),m=function(e){var t=i.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):d(d({},t),e)),n},p=function(e){var t=m(e.components);return i.createElement(r.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},f=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),f=m(n),u=a,k=f["".concat(r,".").concat(u)]||f[u]||s[u]||o;return n?i.createElement(k,d(d({ref:t},p),{},{components:n})):i.createElement(k,d({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,d=new Array(o);d[0]=f;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:a,d[1]=l;for(var m=2;m<o;m++)d[m]=n[m];return i.createElement.apply(null,d)}return i.createElement.apply(null,n)}f.displayName="MDXCreateElement"},7732:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return r},metadata:function(){return m},toc:function(){return p},default:function(){return f}});var i=n(7462),a=n(3366),o=(n(7294),n(3905)),d=["components"],l={},r="Name Resolution Cheatsheet",m={unversionedId:"appendices/cheatsheets/name-resolution-cheatsheet",id:"appendices/cheatsheets/name-resolution-cheatsheet",isDocsHomePage:!1,title:"Name Resolution Cheatsheet",description:"The Name Resolution stage is not that difficult stage of compilation, anyway tricky one.",source:"@site/docs/appendices/cheatsheets/name-resolution-cheatsheet.md",sourceDirName:"appendices/cheatsheets",slug:"/appendices/cheatsheets/name-resolution-cheatsheet",permalink:"/dev-book/docs/appendices/cheatsheets/name-resolution-cheatsheet",editUrl:"https://github.com/jacylang/dev-book/edit/master/docs/appendices/cheatsheets/name-resolution-cheatsheet.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Cheatsheets",permalink:"/dev-book/docs/appendices/cheatsheets/index"},next:{title:"JON files",permalink:"/dev-book/docs/appendices/jon-files/index"}},p=[{value:"Basic structures",id:"basic-structures",children:[{value:"<code>Symbol</code>",id:"symbol",children:[],level:3},{value:"<code>Namespace</code>",id:"namespace",children:[],level:3},{value:"<code>Def</code>",id:"def",children:[],level:3},{value:"<code>DefId</code> &amp; <code>DefIndex</code>",id:"defid--defindex",children:[{value:"<code>ROOT_DEF_ID</code>",id:"root_def_id",children:[],level:4}],level:3},{value:"<code>DefKind</code>",id:"defkind",children:[],level:3},{value:"<code>Vis</code>",id:"vis",children:[],level:3},{value:"<code>PerNS&lt;T&gt;</code>",id:"pernst",children:[],level:3},{value:"<code>PrimTypeSet</code>",id:"primtypeset",children:[],level:3},{value:"<code>Module</code>",id:"module",children:[],level:3},{value:"<code>NameBinding</code>",id:"namebinding",children:[],level:3},{value:"<code>FOSId</code>",id:"fosid",children:[],level:3},{value:"<code>DefTable</code>",id:"deftable",children:[{value:"Fields, Storages",id:"fields-storages",children:[],level:4},{value:"Basic API",id:"basic-api",children:[],level:4}],level:3}],level:2}],s={toc:p};function f(e){var t=e.components,n=(0,a.Z)(e,d);return(0,o.kt)("wrapper",(0,i.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"name-resolution-cheatsheet"},"Name Resolution Cheatsheet"),(0,o.kt)("p",null,"The Name Resolution stage is not that difficult stage of compilation, anyway tricky one.\nHere I tried to collect workflows for different resolution cases and connections between them."),(0,o.kt)("p",null,"Okay, what classes do we have:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ModuleTreeBuilder")," - by the name you can see that this one builds a module tree."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Importer")," - this one resolves ",(0,o.kt)("inlineCode",{parentName:"li"},"use")," declarations and imports new items to the module tree."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"NameResolver")," - resolves names, that is, binds each usage to the definition."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PathResolver")," - helper class that unifies path resolution logic for all name resolution sub-stages."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DefTable")," - common definitions info storage")),(0,o.kt)("h2",{id:"basic-structures"},"Basic structures"),(0,o.kt)("h3",{id:"symbol"},(0,o.kt)("inlineCode",{parentName:"h3"},"Symbol")),(0,o.kt)("p",null,"Identifies interned string, read more about symbols ",(0,o.kt)("a",{parentName:"p",href:"/dev-book/docs/code-docs/interning"},"here")),(0,o.kt)("h3",{id:"namespace"},(0,o.kt)("inlineCode",{parentName:"h3"},"Namespace")),(0,o.kt)("p",null,"An enumeration of namespaces. Each namespace is a separate storage for definitions, thus type names do not collide with value names, etc.\nThere is one special variant - ",(0,o.kt)("inlineCode",{parentName:"p"},"Namespace::Any"),", it is not used in definition storages and mappings, by the way, is used in methods, e.g. to collect definitions with the same name from all namespaces. Never store ",(0,o.kt)("inlineCode",{parentName:"p"},"Namespace::Any")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"DefTable"),", only use it as a helper."),(0,o.kt)("h3",{id:"def"},(0,o.kt)("inlineCode",{parentName:"h3"},"Def")),(0,o.kt)("p",null,"Definition structure, holds ",(0,o.kt)("a",{parentName:"p",href:"#defkind"},(0,o.kt)("inlineCode",{parentName:"a"},"DefKind"))," and ",(0,o.kt)("a",{parentName:"p",href:"#defid-and-defindex"},(0,o.kt)("inlineCode",{parentName:"a"},"DefId")),". You can access particular definition via ",(0,o.kt)("inlineCode",{parentName:"p"},"DefTable::getDef")," or get all, defined, using ",(0,o.kt)("inlineCode",{parentName:"p"},"DefTable::getDefinitions")),(0,o.kt)("h3",{id:"defid--defindex"},(0,o.kt)("inlineCode",{parentName:"h3"},"DefId")," & ",(0,o.kt)("inlineCode",{parentName:"h3"},"DefIndex")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"DefIndex")," is a simple index type, i.e. integer wrapper to create a distinct integer type (C++ does not support it).\n",(0,o.kt)("inlineCode",{parentName:"p"},"DefId")," is a unique definition identifier, currently, it only holds ",(0,o.kt)("inlineCode",{parentName:"p"},"DefIndex")," but might be extended in the future."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"DefId::index")," is the index of vector from ",(0,o.kt)("inlineCode",{parentName:"p"},"DefTable::defs"),". You can get particular definition by ",(0,o.kt)("inlineCode",{parentName:"p"},"DefId")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"DefIndex")," from ",(0,o.kt)("inlineCode",{parentName:"p"},"DefTable")," via ",(0,o.kt)("inlineCode",{parentName:"p"},"getDef"),"."),(0,o.kt)("h4",{id:"root_def_id"},(0,o.kt)("inlineCode",{parentName:"h4"},"ROOT_DEF_ID")),(0,o.kt)("p",null,"The constant for root module definition, used in many places for validations and logic checks."),(0,o.kt)("h3",{id:"defkind"},(0,o.kt)("inlineCode",{parentName:"h3"},"DefKind")),(0,o.kt)("p",null,"Enumeration of definitions kinds. Each kind has some properties, e.g. ",(0,o.kt)("a",{parentName:"p",href:"#namespace"},"namespace")," where it will be defined.\nYou can get ",(0,o.kt)("a",{parentName:"p",href:"#defkind"},(0,o.kt)("inlineCode",{parentName:"a"},"DefKind"))," from ",(0,o.kt)("a",{parentName:"p",href:"#def"},(0,o.kt)("inlineCode",{parentName:"a"},"Def"))," structure if you have one on hand."),(0,o.kt)("p",null,"To find out in which ",(0,o.kt)("a",{parentName:"p",href:"#namespace"},"namespace")," specific ",(0,o.kt)("a",{parentName:"p",href:"#defkind"},(0,o.kt)("inlineCode",{parentName:"a"},"DefKind"))," must be defined call ",(0,o.kt)("inlineCode",{parentName:"p"},"Def::getDefKindNS"),"."),(0,o.kt)("h3",{id:"vis"},(0,o.kt)("inlineCode",{parentName:"h3"},"Vis")),(0,o.kt)("p",null,"Visibility enumeration, for now only ",(0,o.kt)("inlineCode",{parentName:"p"},"Vis::Unset")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Vis::Pub")," exist."),(0,o.kt)("h3",{id:"pernst"},(0,o.kt)("inlineCode",{parentName:"h3"},"PerNS<T>")),(0,o.kt)("p",null,"A helper template structure that stores a value of some type for each namespace."),(0,o.kt)("h3",{id:"primtypeset"},(0,o.kt)("inlineCode",{parentName:"h3"},"PrimTypeSet")),(0,o.kt)("p",null,"Bits-optimized collection of primitive types flags. It can be used to mark specific primitive types used/shadowed, etc.\nUsed by the module to save shadowed primitive types."),(0,o.kt)("h3",{id:"module"},(0,o.kt)("inlineCode",{parentName:"h3"},"Module")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Module")," is a single node of the Module Tree.\nFields:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"kind"),"  - Kind of module, i.e. ",(0,o.kt)("inlineCode",{parentName:"li"},"Def")," (named module bound to some definition) or ",(0,o.kt)("inlineCode",{parentName:"li"},"Block")," (anonymous module). Type is the ",(0,o.kt)("inlineCode",{parentName:"li"},"ModuleKind")," enumeration."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"id")," - Identifier of module - either ",(0,o.kt)("inlineCode",{parentName:"li"},"DefId")," (for ",(0,o.kt)("inlineCode",{parentName:"li"},"ModuleKind::Def"),") or ",(0,o.kt)("inlineCode",{parentName:"li"},"NodeId")," (for ",(0,o.kt)("inlineCode",{parentName:"li"},"ModuleKind::Block"),")."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"parent")," - Optional parent that is another module (only root module does not have a parent)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"nearestModDef")," - Nearest definition of a kind ",(0,o.kt)("inlineCode",{parentName:"li"},"DefKind::Mod"),", always present. For modules which are ",(0,o.kt)("inlineCode",{parentName:"li"},"DefKind::Mod")," by themselves ",(0,o.kt)("em",{parentName:"li"},"nearestModDef")," point to the same modules (root module is also of a kind ",(0,o.kt)("inlineCode",{parentName:"li"},"DefKind"),", thus ",(0,o.kt)("em",{parentName:"li"},"nearestModDef")," of root module is the same as ",(0,o.kt)("a",{parentName:"li",href:"#root_def_id"},(0,o.kt)("inlineCode",{parentName:"a"},"ROOT_DEF_ID")),")."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"perNS")," - ",(0,o.kt)("a",{parentName:"li",href:"#pernst"},"PerNS<map<Symbol, [NameBinding](#namebinding)>>"),". A per-namespace collection of mappings ",(0,o.kt)("strong",{parentName:"li"},"Symbol")," (some name) ",(0,o.kt)("strong",{parentName:"li"},"->")," ",(0,o.kt)("strong",{parentName:"li"},"DefId")," (some definition)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"shadowedPrimTypes")," - module ",(0,o.kt)("a",{parentName:"li",href:"#primtypeset"},(0,o.kt)("inlineCode",{parentName:"a"},"PrimTypeSet")),", i.e. flags showing which primitive types (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"f32"),") are shadowed in the module.")),(0,o.kt)("h3",{id:"namebinding"},(0,o.kt)("inlineCode",{parentName:"h3"},"NameBinding")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Module")," binds names either to ",(0,o.kt)("a",{parentName:"p",href:"#fosid"},(0,o.kt)("inlineCode",{parentName:"a"},"FOS"))," or to some ",(0,o.kt)("a",{parentName:"p",href:"#defid-and-defindex"},"definition"),".\nThis is why ",(0,o.kt)("inlineCode",{parentName:"p"},"NameBinding")," exists, it is an ADT for ",(0,o.kt)("inlineCode",{parentName:"p"},"FOS")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"DefId"),"."),(0,o.kt)("h3",{id:"fosid"},(0,o.kt)("inlineCode",{parentName:"h3"},"FOSId")),(0,o.kt)("p",null,'FOS stands for "Function Overload Set". In ',(0,o.kt)("em",{parentName:"p"},"Jacy")," you can overload functions via different label names, i.e. not by types but ",(0,o.kt)("inlineCode",{parentName:"p"},"func foo(from: int)")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"func foo(to: int)")," can exist together."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"FOSId")," is a unique identifier for one FOS -- a collection of functions with the same name, defined in the same module."),(0,o.kt)("p",null,"For example, in:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jc"},"mod m {\n    func foo(from: int) {}\n\n    func foo(to: int) {}\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"mod m")," only holds ",(0,o.kt)("a",{parentName:"p",href:"#namebinding"},(0,o.kt)("inlineCode",{parentName:"a"},"NameBinding"))," with name ",(0,o.kt)("inlineCode",{parentName:"p"},"foo")," (base name of FOS) which points to ",(0,o.kt)("inlineCode",{parentName:"p"},"FOSId")," of FOS ",(0,o.kt)("inlineCode",{parentName:"p"},"foo")," in ",(0,o.kt)("a",{parentName:"p",href:"#deftable"},(0,o.kt)("inlineCode",{parentName:"a"},"DefTable")),".\nTo access a specific function, at first, you need to get ",(0,o.kt)("inlineCode",{parentName:"p"},"FOSId")," from the module and then go to the ",(0,o.kt)("a",{parentName:"p",href:"#deftable"},(0,o.kt)("inlineCode",{parentName:"a"},"DefTable"))," to search for a suffix."),(0,o.kt)("p",null,"Function suffix is an interned string such as ",(0,o.kt)("inlineCode",{parentName:"p"},"(from:)")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"(to:)"),", i.e. function label list."),(0,o.kt)("h3",{id:"deftable"},(0,o.kt)("inlineCode",{parentName:"h3"},"DefTable")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"DefTable")," holds all data, we need, about definitions and relations between them."),(0,o.kt)("h4",{id:"fields-storages"},"Fields, Storages"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("em",{parentName:"p"},"Direct storage")," mark means that this field is the final storage, i.e. it is not a mapping and other items map to it, ",(0,o.kt)("em",{parentName:"p"},"Indirect storage")," is an opposite.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"defs")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"vector<Def>")," - ",(0,o.kt)("em",{parentName:"li"},"Direct storage")," - Definition collection, ",(0,o.kt)("inlineCode",{parentName:"li"},"DefIndex")," points to index in ",(0,o.kt)("em",{parentName:"li"},"defs"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"modules")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"DefMap<Module::Ptr>")," - ",(0,o.kt)("em",{parentName:"li"},"Direct storage")," - Maps definitions to modules -- ",(0,o.kt)("em",{parentName:"li"},"Named modules"),". Used everywhere, filled in the ",(0,o.kt)("inlineCode",{parentName:"li"},"ModuleTreeBuilder"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"blocks")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"NodeMap<Module::Ptr>")," - ",(0,o.kt)("em",{parentName:"li"},"Direct storage")," - Maps block nodes to modules -- ",(0,o.kt)("em",{parentName:"li"},"Anonymous modules"),". Used everywhere, filled in the ",(0,o.kt)("inlineCode",{parentName:"li"},"ModuleTreeBuilder"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"useDeclModules")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"NodeMap<Module::Ptr>")," - ",(0,o.kt)("em",{parentName:"li"},"Indirect storage")," - Maps node id of ",(0,o.kt)("inlineCode",{parentName:"li"},"use")," item to module it defined it. Used by ",(0,o.kt)("inlineCode",{parentName:"li"},"Importer"),", filled in the ",(0,o.kt)("inlineCode",{parentName:"li"},"ModuleTreeBuilder"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"defVisMap")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"DefMap<Vis>")," - Maps definition to its visibility."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"nodeIdDefIdMap")," -  - Maps definition node id to its ",(0,o.kt)("a",{parentName:"li",href:"#defid-and-defindex"},(0,o.kt)("inlineCode",{parentName:"a"},"DefId")),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"defIdNodeIdMap")," - Maps ",(0,o.kt)("a",{parentName:"li",href:"#defid-and-defindex"},(0,o.kt)("inlineCode",{parentName:"a"},"DefId"))," to definition node id."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"importAliases")," - Maps ",(0,o.kt)("a",{parentName:"li",href:"#defid-and-defindex"},(0,o.kt)("inlineCode",{parentName:"a"},"DefId"))," of import alias, i.e. definition appeared from ",(0,o.kt)("inlineCode",{parentName:"li"},"use")," declaration to another definition (that also might be an import alias).")),(0,o.kt)("h4",{id:"basic-api"},"Basic API"),(0,o.kt)("p",null,"This API is almost a list of helpers to retrieve items from the fields described above."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Working with definitions:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"getDef(",(0,o.kt)("a",{parentName:"em",href:"#defid-and-defindex"},"DefId/DefIndex"),") -> ",(0,o.kt)("a",{parentName:"em",href:"#def"},"Def"))," - get definition by ",(0,o.kt)("inlineCode",{parentName:"li"},"DefId")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"DefIndex"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"getDefUnwind(",(0,o.kt)("a",{parentName:"em",href:"#defid-and-defindex"},"DefId"),") -> ",(0,o.kt)("a",{parentName:"em",href:"#def"},"Def"))," - get definition unwinding aliases (if definition is an ",(0,o.kt)("inlineCode",{parentName:"li"},"ImportAlias"),")."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"getDefVis(",(0,o.kt)("a",{parentName:"em",href:"#defid-and-defindex"},"DefId"),") -> ",(0,o.kt)("a",{parentName:"em",href:"#vis"},"Vis"))," - get definition visibility."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"getNodeIdByDefId(",(0,o.kt)("a",{parentName:"em",href:"#defid-and-defindex"},"DefId"),") -> NodeId")," - get node id of definition node by definition id."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"getDefIdByNodeId(NodeId) -> ",(0,o.kt)("a",{parentName:"em",href:"#defid-and-defindex"},"DefId"))," - get definition id by node id."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"getDefNameSpan(",(0,o.kt)("a",{parentName:"em",href:"#defid-and-defindex"},"DefId"),") -> Span")," - get span of definition identifier (e.g. in ",(0,o.kt)("inlineCode",{parentName:"li"},"func foo() {}")," it returns span for ",(0,o.kt)("inlineCode",{parentName:"li"},"foo"),")."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Working with modules:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"getModule(",(0,o.kt)("a",{parentName:"em",href:"#defid-and-defindex"},"DefId"),") -> ",(0,o.kt)("a",{parentName:"em",href:"#module"},"Module::Ptr"))," - get module by definition id."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"getBlock(NodeId) -> ",(0,o.kt)("a",{parentName:"em",href:"#module"},"Module::Ptr"))," - get block (anonymous module) by node id."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"getFuncModule(",(0,o.kt)("a",{parentName:"em",href:"#fosid"},"FOSId"),", Symbol) -> ",(0,o.kt)("a",{parentName:"em",href:"#module"},"Module::Ptr"))," - get function module by ",(0,o.kt)("inlineCode",{parentName:"li"},"FOSId")," and specific suffix, together they non-ambiguously specify some function."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"addModule(",(0,o.kt)("a",{parentName:"em",href:"#defid-and-defindex"},"DefId"),", ",(0,o.kt)("a",{parentName:"em",href:"#module"},"Module::Ptr"),")")," - Add named module, binding it by ",(0,o.kt)("inlineCode",{parentName:"li"},"DefId"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"addBlock(NodeId, ",(0,o.kt)("a",{parentName:"em",href:"#module"},"Module::Ptr"),")")," - Add block (anonymous module), binding it by NodeId.")))))}f.isMDXComponent=!0}}]);