"use strict";(self.webpackChunkdev_book=self.webpackChunkdev_book||[]).push([[124],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(n),m=i,f=d["".concat(p,".").concat(m)]||d[m]||u[m]||o;return n?r.createElement(f,a(a({ref:t},c),{},{components:n})):r.createElement(f,a({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var s=2;s<o;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8149:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return c},default:function(){return d}});var r=n(87462),i=n(63366),o=(n(67294),n(3905)),a=["components"],l={},p="HIR Pretty printing",s={unversionedId:"compiler-workflow/lowering/hir-pretty-print",id:"compiler-workflow/lowering/hir-pretty-print",isDocsHomePage:!1,title:"HIR Pretty printing",description:"As we have the AstPrinter which prints AST structure (mostly) in the same way user wrote it, we need to be able to print the HIR structure.",source:"@site/docs/compiler-workflow/lowering/hir-pretty-print.md",sourceDirName:"compiler-workflow/lowering",slug:"/compiler-workflow/lowering/hir-pretty-print",permalink:"/dev-book/docs/compiler-workflow/lowering/hir-pretty-print",editUrl:"https://github.com/jacylang/dev-book/edit/master/docs/compiler-workflow/lowering/hir-pretty-print.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Name resolution",permalink:"/dev-book/docs/compiler-workflow/name-res-stage/name-resolution"},next:{title:"HIR",permalink:"/dev-book/docs/compiler-workflow/lowering/hir"}},c=[{value:"Printing implicit syntax",id:"printing-implicit-syntax",children:[],level:2}],u={toc:c};function d(e){var t=e.components,n=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"hir-pretty-printing"},"HIR Pretty printing"),(0,o.kt)("p",null,"As we have the ",(0,o.kt)("inlineCode",{parentName:"p"},"AstPrinter")," which prints AST structure (mostly) in the same way user wrote it, we need to be able to print the HIR structure."),(0,o.kt)("p",null,"Whereas AST is a straightforward representation of the user's code, HIR is much more simplified and does not include full information about the user's code directly inside. For example, we don't have kind of ",(0,o.kt)("inlineCode",{parentName:"p"},"ParenExpr")," (parenthesized expression) as HIR is a tree structure (not really, but in the case of expressions is always a tree of expressions) which gives us enough information about precedence, i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"(1 + 2) * 3")," becomes ",(0,o.kt)("inlineCode",{parentName:"p"},"Infix(Infix(1 + 2), '*', Literal(3))")," and we know that ",(0,o.kt)("inlineCode",{parentName:"p"},"Infix")," will be computed first -- no need for parentheses."),(0,o.kt)("p",null,"And here we come up with a problem, how do we print ",(0,o.kt)("inlineCode",{parentName:"p"},"(1 + 2) * 3")," if we don't have ",(0,o.kt)("inlineCode",{parentName:"p"},"ParenExpr"),"?"),(0,o.kt)("h2",{id:"printing-implicit-syntax"},"Printing implicit syntax"),(0,o.kt)("p",null,"I have an example above where we don't have precise information about user code but need to get it someway.\nTo solve the problem with the absence of ",(0,o.kt)("inlineCode",{parentName:"p"},"ParenExpr")," we do:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"See an ",(0,o.kt)("inlineCode",{parentName:"li"},"InfixExpr")," node"),(0,o.kt)("li",{parentName:"ol"},"And if either its LHS or RHS is an ",(0,o.kt)("inlineCode",{parentName:"li"},"InfixExpr")," with a lower precedence"),(0,o.kt)("li",{parentName:"ol"},"We put parenthesis around it.")),(0,o.kt)("p",null,"Pretty simple: in ",(0,o.kt)("inlineCode",{parentName:"p"},"(1 + 2) * 3")," that has AST ",(0,o.kt)("inlineCode",{parentName:"p"},"Infix(Infix(1 + 2), '*', Literal(3))"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Infix(1 + 2)")," is deeper in the tree but ",(0,o.kt)("inlineCode",{parentName:"p"},"+")," has lower precedence than ",(0,o.kt)("inlineCode",{parentName:"p"},"*"),", thus we know that user wrote ",(0,o.kt)("inlineCode",{parentName:"p"},"(1 + 2) * 3"),", no other case can result this AST."),(0,o.kt)("p",null,"But often, when we lower AST, we don't need to get what the user wrote in the code, but what the result is. We don't print \"AST from HIR\", we print HIR as it is to see what the heck have we made \ud83d\ude38.\nAnd for cases when we lower a syntax unit but have to know that some lowering was applied we can store a flag (boolean or an enum, for example)."))}d.isMDXComponent=!0}}]);