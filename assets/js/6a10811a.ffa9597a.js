"use strict";(self.webpackChunkdev_book=self.webpackChunkdev_book||[]).push([[9960],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=c(n),u=o,h=m["".concat(s,".").concat(u)]||m[u]||p[u]||i;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},40109:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return d},default:function(){return m}});var a=n(87462),o=n(63366),i=(n(67294),n(3905)),r=["components"],l={},s="Code testing tool",c={unversionedId:"ideas/code-testing-tool",id:"ideas/code-testing-tool",isDocsHomePage:!1,title:"Code testing tool",description:"This is mostly not just an idea but a task description, I want a tool that allows checking for errors with annotations in comments.",source:"@site/docs/ideas/code-testing-tool.md",sourceDirName:"ideas",slug:"/ideas/code-testing-tool",permalink:"/dev-book/docs/ideas/code-testing-tool",editUrl:"https://github.com/jacylang/dev-book/edit/master/docs/ideas/code-testing-tool.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Code Style Conventions",permalink:"/dev-book/docs/ideas/code-style-conventions"},next:{title:"Ideas",permalink:"/dev-book/docs/ideas/index"}},d=[{value:"What features do I want",id:"what-features-do-i-want",children:[{value:"About message comment structure",id:"about-message-comment-structure",children:[],level:3},{value:"CLI args in comments",id:"cli-args-in-comments",children:[],level:3},{value:"Spanned error",id:"spanned-error",children:[{value:"Implementation problem",id:"implementation-problem",children:[],level:4}],level:3}],level:2},{value:"Implementation specification",id:"implementation-specification",children:[{value:"Collecting messages",id:"collecting-messages",children:[],level:3}],level:2}],p={toc:d};function m(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"code-testing-tool"},"Code testing tool"),(0,i.kt)("p",null,"This is mostly not just an idea but a task description, I want a tool that allows checking for errors with annotations in comments."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jc"},"enum Enumeration // message:error 'Expected `enum` body'\n")),(0,i.kt)("p",null,"This tool would be really helpful for parser testing, by the way, it might be suitable for type check, etc.\nBut let's focus on parsing first."),(0,i.kt)("h2",{id:"what-features-do-i-want"},"What features do I want"),(0,i.kt)("h3",{id:"about-message-comment-structure"},"About message comment structure"),(0,i.kt)("p",null,"At first, I need to decide what properties of messages (error, warn, etc.) must be required in test comments.\nFor now (and ",(0,i.kt)("inlineCode",{parentName:"p"},"Message")," structure might be extended in the future) ",(0,i.kt)("inlineCode",{parentName:"p"},"Message")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Label")," are structured as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c++"},"struct Label {\n    Kind kind; // Primary/Help/Aux\n    Span span; // Span of the label\n    std::string text; // Label text\n}\n\nstruct Message {\n    Kind kind; // Error/Warn/None\n    std::string text; // Text of the message\n    EID eid; // Explanation identifier\n    Option<Label> primaryLabel; // Primary label of the message\n    Label::List labels; // Additional labels\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"I think that checking the only text of a message would be enough, so we can through away label checks, as we want to check if an error appears but not how we described it."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"Message::Kind")," already defined in the syntax ",(0,i.kt)("inlineCode",{parentName:"li"},"message:{{kind}}"),", is required."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"Message::EID"),' should be optional as I think, like "more specific check". So we can add a kind of annotation for it, e.g. ',(0,i.kt)("inlineCode",{parentName:"li"},"message:error 'Expected `enum` body' @EID:123"),".")),(0,i.kt)("p",null,"As we already have a syntax for ",(0,i.kt)("inlineCode",{parentName:"p"},"EID")," annotation then we can use it for all annotations, e.g. for spans. This will give are concise and extensible syntax for message properties."),(0,i.kt)("p",null,"That's all we can get from messages for now."),(0,i.kt)("h3",{id:"cli-args-in-comments"},"CLI args in comments"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"CodeTest")," must be a separate CLI command for ",(0,i.kt)("inlineCode",{parentName:"p"},"jc"),", i.e. like default one - ",(0,i.kt)("inlineCode",{parentName:"p"},"compile"),", this will give us more control, but there's a big downside - we'll need to support different kinds of interfaces - one for raw compilation and one for code testing."),(0,i.kt)("p",null,'By the way, it would be inextensible not to tune the code-test process for each file separately, thus, we need kind of "flags" right inside the code-test file comments.'),(0,i.kt)("p",null,"Getting ahead of myself, I would say that we need to set compilation target for each file, but let's focus on more simple things. Let's say \"Stage\" - the important flag we need to say the compiler only to run stages before and including specified one. We already have this feature in ",(0,i.kt)("inlineCode",{parentName:"p"},"compile")," command, so... copy-paste \ud83d\ude3a."),(0,i.kt)("h3",{id:"spanned-error"},"Spanned error"),(0,i.kt)("p",null,"In the example above I just wrote an error with some text, but it would be nice to be able to check the position of the error too.\nSpan syntax, as for ",(0,i.kt)("inlineCode",{parentName:"p"},"EID"),", is written as an annotation ",(0,i.kt)("inlineCode",{parentName:"p"},"@at{16}"),' meaning "at 16 symbol place" or ',(0,i.kt)("inlineCode",{parentName:"p"},"@at{16-17}"),' meaning "from 16 to 17 symbol place".'),(0,i.kt)("h4",{id:"implementation-problem"},"Implementation problem"),(0,i.kt)("p",null,"Span in ",(0,i.kt)("em",{parentName:"p"},"Jacy"),' compiler stored as a position and length (meaning "from char C with length L"), and it might be tricky to convert all the spans to the "line:number" form.'),(0,i.kt)("h2",{id:"implementation-specification"},"Implementation specification"),(0,i.kt)("h3",{id:"collecting-messages"},"Collecting messages"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"We parse the code with in a special ",(0,i.kt)("inlineCode",{parentName:"li"},"ParserMode = CodeTest")," which collects all comments placed after items."),(0,i.kt)("li",{parentName:"ol"},"We go through all the comments we collected and leave only the ones starting with ",(0,i.kt)("inlineCode",{parentName:"li"},"message:")," and save them."),(0,i.kt)("li",{parentName:"ol"},"If some of the comments have the ",(0,i.kt)("inlineCode",{parentName:"li"},"@at")," attribute, we set a specific span for them."),(0,i.kt)("li",{parentName:"ol"},"If the ",(0,i.kt)("inlineCode",{parentName:"li"},"@at")," attribute only specifies the by-char position, we set the current line (line where at the end of which comment is placed) number for it."),(0,i.kt)("li",{parentName:"ol"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"@at"),' has at least a line number specified, we do nothing with it and then, at the check stage, look at it as "an error at line N"'),(0,i.kt)("li",{parentName:"ol"})))}m.isMDXComponent=!0}}]);