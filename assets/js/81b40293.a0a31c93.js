"use strict";(self.webpackChunkdev_book=self.webpackChunkdev_book||[]).push([[1701],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),f=i,y=d["".concat(l,".").concat(f)]||d[f]||u[f]||a;return n?r.createElement(y,s(s({ref:t},p),{},{components:n})):r.createElement(y,s({ref:t},p))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var c=2;c<a;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8833:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),s=["components"],o={},l="Types as first-class citizens",c={unversionedId:"ideas/types-as-first-class-citizens",id:"ideas/types-as-first-class-citizens",isDocsHomePage:!1,title:"Types as first-class citizens",description:"The idea is growing from powerfulness of compile-time evaluation. All types must be known at compile-time, and as far as",source:"@site/docs/ideas/types-as-first-class-citizens.md",sourceDirName:"ideas",slug:"/ideas/types-as-first-class-citizens",permalink:"/dev-book/docs/ideas/types-as-first-class-citizens",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/ideas/types-as-first-class-citizens.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Arguments labels",permalink:"/dev-book/docs/ideas/named-arg-alias"},next:{title:"Attributes for extended tools",permalink:"/dev-book/docs/ideas/extended-tools/attributes"}},p=[{value:"Type declarations",id:"type-declarations",children:[{value:"Dynamic type checks",id:"dynamic-type-checks",children:[],level:3},{value:"Returning types",id:"returning-types",children:[],level:3}],level:2}],u={toc:p};function d(e){var t=e.components,n=(0,i.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"types-as-first-class-citizens"},"Types as first-class citizens"),(0,a.kt)("p",null,'The idea is growing from powerfulness of compile-time evaluation. All types must be known at compile-time, and as far as\nI am going to implement comprehensive CTE system, "types as first-class citizens" sounds really fittable in this\npicture.'),(0,a.kt)("h2",{id:"type-declarations"},"Type declarations"),(0,a.kt)("p",null,"At first, I thought it would be nice if we could use ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," for declaring not only aliases to types but also use them in\nthe way as type variables. Types are items, all items are forwardly declared, that is, if some type is declared in a\nscope, it can be used before it actually appears in the code. Example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jc"},"func foo {\n    let a: MyType = 123;\n\n    type MyType = i32;\n}\n")),(0,a.kt)("p",null,"For me, it looks problematic as the control flow with types would be either impossible or weird."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jc"},"func foo {\n    if a {\n        a = i64;\n    }\n\n    type a = i32;\n}\n")),(0,a.kt)("p",null,"Hmm... WTF???"),(0,a.kt)("p",null,"Actually, control-flow for types is useless in the way of using declared aliases. Aliases are not dynamic, thus if we\ndeclared one -- we already know what type it is. But what if we don't know what type we receive? E.g. in generics, we\nget type parameter which is unknown, and what if it would be possible to check this type as a value?"),(0,a.kt)("h3",{id:"dynamic-type-checks"},"Dynamic type checks"),(0,a.kt)("p",null,"Example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jc"},"func foo<T>(arg: T) {\n    if T == bool {\n        print(\"We've got 'bool'\");\n    } else {\n        print(\"We've got not a 'bool'\");\n    }\n}\n")),(0,a.kt)("p",null,"Looks useful, but... not, actually. I cannot come up with a case when this cannot be described with generics and\nconstraints."),(0,a.kt)("h3",{id:"returning-types"},"Returning types"))}d.isMDXComponent=!0}}]);